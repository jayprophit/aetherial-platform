import { pgTable, serial, integer, varchar, text, decimal, timestamp, boolean, jsonb, index } from 'drizzle-orm/pg-core';

/**
 * Trading Strategies
 * Stores different algorithmic trading strategies
 */
export const tradingStrategies = pgTable('trading_strategies', {
  id: serial('id').primaryKey(),
  name: varchar('name', { length: 255 }).notNull(),
  type: varchar('type', { length: 100 }).notNull(), // 'momentum', 'mean_reversion', 'arbitrage', 'grid', 'dca', 'breakout', 'scalping', 'swing'
  description: text('description'),
  parameters: jsonb('parameters').notNull(), // Strategy-specific parameters
  riskLevel: varchar('risk_level', { length: 50 }).notNull(), // 'low', 'medium', 'high'
  minCapital: decimal('min_capital', { precision: 20, scale: 8 }).notNull(),
  expectedReturn: decimal('expected_return', { precision: 10, scale: 2 }), // Annual percentage
  maxDrawdown: decimal('max_drawdown', { precision: 10, scale: 2 }), // Maximum expected loss percentage
  isActive: boolean('is_active').default(true).notNull(),
  createdBy: integer('created_by'),
  createdAt: timestamp('created_at').defaultNow().notNull(),
  updatedAt: timestamp('updated_at').defaultNow().notNull(),
}, (table) => ({
  typeIdx: index('trading_strategies_type_idx').on(table.type),
  activeIdx: index('trading_strategies_active_idx').on(table.isActive),
}));

/**
 * Trading Bots
 * User-configured trading bots
 */
export const tradingBots = pgTable('trading_bots', {
  id: serial('id').primaryKey(),
  userId: integer('user_id').notNull(),
  name: varchar('name', { length: 255 }).notNull(),
  strategyId: integer('strategy_id').notNull(),
  exchange: varchar('exchange', { length: 100 }).notNull(), // 'binance', 'uniswap', 'sushiswap', 'pancakeswap'
  tradingPair: varchar('trading_pair', { length: 50 }).notNull(), // 'BTC/USDT', 'ETH/USDT'
  capital: decimal('capital', { precision: 20, scale: 8 }).notNull(),
  status: varchar('status', { length: 50 }).default('inactive').notNull(), // 'active', 'inactive', 'paused', 'error'
  config: jsonb('config').notNull(), // Bot-specific configuration
  performance: jsonb('performance'), // Performance metrics
  lastExecutedAt: timestamp('last_executed_at'),
  createdAt: timestamp('created_at').defaultNow().notNull(),
  updatedAt: timestamp('updated_at').defaultNow().notNull(),
}, (table) => ({
  userIdx: index('trading_bots_user_idx').on(table.userId),
  statusIdx: index('trading_bots_status_idx').on(table.status),
  exchangeIdx: index('trading_bots_exchange_idx').on(table.exchange),
}));

/**
 * Trading Orders
 * All trading orders executed by bots
 */
export const tradingOrders = pgTable('trading_orders', {
  id: serial('id').primaryKey(),
  botId: integer('bot_id').notNull(),
  userId: integer('user_id').notNull(),
  exchange: varchar('exchange', { length: 100 }).notNull(),
  orderId: varchar('order_id', { length: 255 }), // Exchange order ID
  tradingPair: varchar('trading_pair', { length: 50 }).notNull(),
  type: varchar('type', { length: 50 }).notNull(), // 'market', 'limit', 'stop_loss', 'take_profit'
  side: varchar('side', { length: 10 }).notNull(), // 'buy', 'sell'
  amount: decimal('amount', { precision: 20, scale: 8 }).notNull(),
  price: decimal('price', { precision: 20, scale: 8 }).notNull(),
  filled: decimal('filled', { precision: 20, scale: 8 }).default('0').notNull(),
  remaining: decimal('remaining', { precision: 20, scale: 8 }).notNull(),
  cost: decimal('cost', { precision: 20, scale: 8 }).notNull(),
  fee: decimal('fee', { precision: 20, scale: 8 }).default('0').notNull(),
  feeCurrency: varchar('fee_currency', { length: 20 }),
  status: varchar('status', { length: 50 }).notNull(), // 'pending', 'open', 'closed', 'canceled', 'expired', 'rejected'
  profit: decimal('profit', { precision: 20, scale: 8 }),
  profitPercentage: decimal('profit_percentage', { precision: 10, scale: 2 }),
  metadata: jsonb('metadata'), // Additional order data
  executedAt: timestamp('executed_at'),
  closedAt: timestamp('closed_at'),
  createdAt: timestamp('created_at').defaultNow().notNull(),
}, (table) => ({
  botIdx: index('trading_orders_bot_idx').on(table.botId),
  userIdx: index('trading_orders_user_idx').on(table.userId),
  statusIdx: index('trading_orders_status_idx').on(table.status),
  pairIdx: index('trading_orders_pair_idx').on(table.tradingPair),
}));

/**
 * Trading Signals
 * Buy/sell signals generated by strategies
 */
export const tradingSignals = pgTable('trading_signals', {
  id: serial('id').primaryKey(),
  strategyId: integer('strategy_id').notNull(),
  exchange: varchar('exchange', { length: 100 }).notNull(),
  tradingPair: varchar('trading_pair', { length: 50 }).notNull(),
  signal: varchar('signal', { length: 20 }).notNull(), // 'buy', 'sell', 'hold'
  strength: decimal('strength', { precision: 5, scale: 2 }).notNull(), // 0-100
  price: decimal('price', { precision: 20, scale: 8 }).notNull(),
  indicators: jsonb('indicators').notNull(), // Technical indicators used
  reasoning: text('reasoning'),
  expiresAt: timestamp('expires_at'),
  createdAt: timestamp('created_at').defaultNow().notNull(),
}, (table) => ({
  strategyIdx: index('trading_signals_strategy_idx').on(table.strategyId),
  pairIdx: index('trading_signals_pair_idx').on(table.tradingPair),
  signalIdx: index('trading_signals_signal_idx').on(table.signal),
}));

/**
 * Backtesting Results
 * Results from strategy backtesting
 */
export const backtestingResults = pgTable('backtesting_results', {
  id: serial('id').primaryKey(),
  userId: integer('user_id').notNull(),
  strategyId: integer('strategy_id').notNull(),
  exchange: varchar('exchange', { length: 100 }).notNull(),
  tradingPair: varchar('trading_pair', { length: 50 }).notNull(),
  startDate: timestamp('start_date').notNull(),
  endDate: timestamp('end_date').notNull(),
  initialCapital: decimal('initial_capital', { precision: 20, scale: 8 }).notNull(),
  finalCapital: decimal('final_capital', { precision: 20, scale: 8 }).notNull(),
  totalReturn: decimal('total_return', { precision: 10, scale: 2 }).notNull(),
  totalTrades: integer('total_trades').notNull(),
  winningTrades: integer('winning_trades').notNull(),
  losingTrades: integer('losing_trades').notNull(),
  winRate: decimal('win_rate', { precision: 5, scale: 2 }).notNull(),
  maxDrawdown: decimal('max_drawdown', { precision: 10, scale: 2 }).notNull(),
  sharpeRatio: decimal('sharpe_ratio', { precision: 10, scale: 4 }),
  profitFactor: decimal('profit_factor', { precision: 10, scale: 4 }),
  avgWin: decimal('avg_win', { precision: 20, scale: 8 }),
  avgLoss: decimal('avg_loss', { precision: 20, scale: 8 }),
  detailedResults: jsonb('detailed_results'), // Trade-by-trade results
  createdAt: timestamp('created_at').defaultNow().notNull(),
}, (table) => ({
  userIdx: index('backtesting_results_user_idx').on(table.userId),
  strategyIdx: index('backtesting_results_strategy_idx').on(table.strategyId),
}));

/**
 * Portfolio Positions
 * Current holdings across exchanges
 */
export const portfolioPositions = pgTable('portfolio_positions', {
  id: serial('id').primaryKey(),
  userId: integer('user_id').notNull(),
  exchange: varchar('exchange', { length: 100 }).notNull(),
  asset: varchar('asset', { length: 20 }).notNull(), // 'BTC', 'ETH', 'USDT'
  amount: decimal('amount', { precision: 20, scale: 8 }).notNull(),
  averagePrice: decimal('average_price', { precision: 20, scale: 8 }).notNull(),
  currentPrice: decimal('current_price', { precision: 20, scale: 8 }),
  totalCost: decimal('total_cost', { precision: 20, scale: 8 }).notNull(),
  currentValue: decimal('current_value', { precision: 20, scale: 8 }),
  unrealizedPnl: decimal('unrealized_pnl', { precision: 20, scale: 8 }),
  unrealizedPnlPercentage: decimal('unrealized_pnl_percentage', { precision: 10, scale: 2 }),
  updatedAt: timestamp('updated_at').defaultNow().notNull(),
}, (table) => ({
  userIdx: index('portfolio_positions_user_idx').on(table.userId),
  assetIdx: index('portfolio_positions_asset_idx').on(table.asset),
}));

/**
 * Risk Management Rules
 * User-defined risk management rules
 */
export const riskManagementRules = pgTable('risk_management_rules', {
  id: serial('id').primaryKey(),
  userId: integer('user_id').notNull(),
  botId: integer('bot_id'),
  name: varchar('name', { length: 255 }).notNull(),
  type: varchar('type', { length: 100 }).notNull(), // 'stop_loss', 'take_profit', 'max_position_size', 'max_daily_loss', 'trailing_stop'
  parameters: jsonb('parameters').notNull(),
  isActive: boolean('is_active').default(true).notNull(),
  createdAt: timestamp('created_at').defaultNow().notNull(),
  updatedAt: timestamp('updated_at').defaultNow().notNull(),
}, (table) => ({
  userIdx: index('risk_management_rules_user_idx').on(table.userId),
  botIdx: index('risk_management_rules_bot_idx').on(table.botId),
}));

/**
 * Market Data Cache
 * Cached market data for performance
 */
export const marketDataCache = pgTable('market_data_cache', {
  id: serial('id').primaryKey(),
  exchange: varchar('exchange', { length: 100 }).notNull(),
  tradingPair: varchar('trading_pair', { length: 50 }).notNull(),
  timeframe: varchar('timeframe', { length: 20 }).notNull(), // '1m', '5m', '15m', '1h', '4h', '1d'
  timestamp: timestamp('timestamp').notNull(),
  open: decimal('open', { precision: 20, scale: 8 }).notNull(),
  high: decimal('high', { precision: 20, scale: 8 }).notNull(),
  low: decimal('low', { precision: 20, scale: 8 }).notNull(),
  close: decimal('close', { precision: 20, scale: 8 }).notNull(),
  volume: decimal('volume', { precision: 20, scale: 8 }).notNull(),
  indicators: jsonb('indicators'), // Calculated technical indicators
  createdAt: timestamp('created_at').defaultNow().notNull(),
}, (table) => ({
  pairTimeframeIdx: index('market_data_cache_pair_timeframe_idx').on(table.tradingPair, table.timeframe),
  timestampIdx: index('market_data_cache_timestamp_idx').on(table.timestamp),
}));

// Type exports for TypeScript
export type TradingStrategy = typeof tradingStrategies.$inferSelect;
export type NewTradingStrategy = typeof tradingStrategies.$inferInsert;

export type TradingBot = typeof tradingBots.$inferSelect;
export type NewTradingBot = typeof tradingBots.$inferInsert;

export type TradingOrder = typeof tradingOrders.$inferSelect;
export type NewTradingOrder = typeof tradingOrders.$inferInsert;

export type TradingSignal = typeof tradingSignals.$inferSelect;
export type NewTradingSignal = typeof tradingSignals.$inferInsert;

export type BacktestingResult = typeof backtestingResults.$inferSelect;
export type NewBacktestingResult = typeof backtestingResults.$inferInsert;

export type PortfolioPosition = typeof portfolioPositions.$inferSelect;
export type NewPortfolioPosition = typeof portfolioPositions.$inferInsert;

export type RiskManagementRule = typeof riskManagementRules.$inferSelect;
export type NewRiskManagementRule = typeof riskManagementRules.$inferInsert;

export type MarketDataCache = typeof marketDataCache.$inferSelect;
export type NewMarketDataCache = typeof marketDataCache.$inferInsert;

